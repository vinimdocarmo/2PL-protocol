package frontend;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.swing.table.DefaultTableModel;

import executer.Controller;

public class ResultsWindow extends javax.swing.JFrame {

	private static final long serialVersionUID = 8369318658025812525L;

	/**
	 * Creates new form InterfaceResultado
	 */
	public ResultsWindow() {
		KeyListener listener = new KeyListener() {
			
			@Override
			public void keyTyped(KeyEvent e) {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void keyReleased(KeyEvent e) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void keyPressed(KeyEvent e) {
				// TODO Auto-generated method stub
				if (e.getKeyCode() == KeyEvent.VK_SPACE) {
					if (Controller.paused.get()) {
						Controller.paused.set(false);
					} else {
						Controller.paused.set(true);
					}
				}
			}
		};
		
		addKeyListener(listener);
		initComponents();
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated
	// Code">//GEN-BEGIN:initComponents
	private void initComponents() {
		
		jPanel1 = new javax.swing.JPanel();
		jLabel1 = new javax.swing.JLabel();
		jScrollPane1 = new javax.swing.JScrollPane();
		transactionsTable = new javax.swing.JTable();
		jLabel2 = new javax.swing.JLabel();
		jScrollPane2 = new javax.swing.JScrollPane();
		graphTable = new javax.swing.JTable();
		jLabel3 = new javax.swing.JLabel();
		jScrollPane3 = new javax.swing.JScrollPane();
		queueTable = new javax.swing.JTable();
		jLabel4 = new javax.swing.JLabel();
		jScrollPane4 = new javax.swing.JScrollPane();
		schedulerTable = new javax.swing.JTable();
		jLabel5 = new javax.swing.JLabel();
		jScrollPane5 = new javax.swing.JScrollPane();
		randomizerTable = new javax.swing.JTable();
		jLabel6 = new javax.swing.JLabel();
		jScrollPane6 = new javax.swing.JScrollPane();
		blockTable = new javax.swing.JTable();
		
		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		setTitle("2PL-strict protocol");
		setMinimumSize(new java.awt.Dimension(1360, 725));

		jPanel1.setMaximumSize(new java.awt.Dimension(1327, 725));
		jPanel1.setMinimumSize(new java.awt.Dimension(1327, 725));
		jPanel1.setPreferredSize(new java.awt.Dimension(1327, 725));
		jPanel1.setVerifyInputWhenFocusTarget(false);
		
		jLabel1.setText("Transactions:");

		transactionsTable.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {},
				new String[] { "ID", "Operações", "Timestamp" }) {
			private static final long serialVersionUID = -8243551619539624760L;

			Class[] types = new Class[] { java.lang.Integer.class, java.lang.String.class, java.lang.String.class };
			boolean[] canEdit = new boolean[] { false, false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});

		jScrollPane1.setViewportView(transactionsTable);

		if (transactionsTable.getColumnModel().getColumnCount() > 0) {
			transactionsTable.getColumnModel().getColumn(0).setMaxWidth(40);
			transactionsTable.getColumnModel().getColumn(1).setMaxWidth(500);
			transactionsTable.getColumnModel().getColumn(2).setMaxWidth(140);
		}

		jLabel2.setText("Waiting graph:");

		graphTable.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {

		}, new String[] { "Source", "Destination" }) {

			private static final long serialVersionUID = 7412000343411337146L;
			Class[] types = new Class[] { java.lang.String.class, java.lang.String.class, java.lang.String.class,
					java.lang.String.class };
			boolean[] canEdit = new boolean[] { false, false, false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});

		jScrollPane2.setViewportView(graphTable);

		jLabel3.setText("Queue:");

		queueTable.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {

		}, new String[] { "-", "Transaction", "Operation", "Waiting for" }) {
			private static final long serialVersionUID = 3012587335578963916L;
			Class[] types = new Class[] { java.lang.String.class, java.lang.Integer.class, java.lang.String.class, java.lang.String.class };
			boolean[] canEdit = new boolean[] { false, false, false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});

		jScrollPane3.setViewportView(queueTable);

		jLabel4.setText("Scheduler:");

		schedulerTable.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {

		}, new String[] { "Transaction id", "Operation", "Timestamp"  }) {
			private static final long serialVersionUID = -8762742015118546328L;
			Class[] types = new Class[] { java.lang.Integer.class, java.lang.String.class, java.lang.String.class };
			boolean[] canEdit = new boolean[] { false, false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});
		
		jScrollPane4.setViewportView(schedulerTable);

		jLabel5.setText("Transaction Randomizer:");

		randomizerTable.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {

		}, new String[] { "Transaction", "Time" }) {
			private static final long serialVersionUID = 1773878762252139978L;
			Class[] types = new Class[] { java.lang.Integer.class, java.lang.String.class };
			boolean[] canEdit = new boolean[] { false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});

		jScrollPane5.setViewportView(randomizerTable);

		jLabel6.setText("Blocks:");

		blockTable.setModel(new javax.swing.table.DefaultTableModel(new Object[][] {

		}, new String[] { "Blocked item", "Lock type", "Transaction", "Time" }) {
			private static final long serialVersionUID = 3258744779282892139L;
			Class[] types = new Class[] { java.lang.String.class, java.lang.String.class, java.lang.Integer.class, java.lang.String.class };
			boolean[] canEdit = new boolean[] { false, false, false, false };

			public Class getColumnClass(int columnIndex) {
				return types[columnIndex];
			}

			public boolean isCellEditable(int rowIndex, int columnIndex) {
				return canEdit[columnIndex];
			}
		});

		jScrollPane6.setViewportView(blockTable);

		javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
		jPanel1.setLayout(jPanel1Layout);
		jPanel1Layout
				.setHorizontalGroup(
						jPanel1Layout
								.createParallelGroup(
										javax.swing.GroupLayout.Alignment.LEADING)
								.addGroup(
										jPanel1Layout.createSequentialGroup().addContainerGap()
												.addGroup(
														jPanel1Layout
																.createParallelGroup(
																		javax.swing.GroupLayout.Alignment.LEADING)
																.addComponent(jLabel1).addComponent(jLabel6)
																.addComponent(jLabel3)
																.addComponent(jLabel2)
																.addComponent(jScrollPane2,
																		javax.swing.GroupLayout.PREFERRED_SIZE, 594,
																		javax.swing.GroupLayout.PREFERRED_SIZE)
																.addGroup(jPanel1Layout
																		.createParallelGroup(
																				javax.swing.GroupLayout.Alignment.TRAILING,
																				false)
																		.addComponent(jScrollPane3,
																				javax.swing.GroupLayout.Alignment.LEADING,
																				javax.swing.GroupLayout.DEFAULT_SIZE,
																				593, Short.MAX_VALUE)
																		.addComponent(jScrollPane6,
																				javax.swing.GroupLayout.Alignment.LEADING)
																		.addComponent(jScrollPane1,
																				javax.swing.GroupLayout.Alignment.LEADING)))
												.addGap(18, 18, 18)
												.addGroup(
														jPanel1Layout
																.createParallelGroup(
																		javax.swing.GroupLayout.Alignment.LEADING)
																.addComponent(jLabel5).addComponent(jScrollPane5,
																		javax.swing.GroupLayout.PREFERRED_SIZE, 214,
																		javax.swing.GroupLayout.PREFERRED_SIZE))
												.addGap(18, 18, 18)
												.addGroup(jPanel1Layout
														.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
														.addGroup(jPanel1Layout.createSequentialGroup().addGap(1, 1, 1)
																.addComponent(jLabel4))
														.addComponent(jScrollPane4,
																javax.swing.GroupLayout.PREFERRED_SIZE,
																javax.swing.GroupLayout.DEFAULT_SIZE,
																javax.swing.GroupLayout.PREFERRED_SIZE))
												.addContainerGap(21, Short.MAX_VALUE)));
		jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(javax.swing.GroupLayout.Alignment.TRAILING,
						jPanel1Layout.createSequentialGroup().addContainerGap()
								.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
										.addComponent(jLabel1).addComponent(jLabel4).addComponent(jLabel5))
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
								.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
										.addGroup(jPanel1Layout.createSequentialGroup()
												.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 93,
														javax.swing.GroupLayout.PREFERRED_SIZE)
												.addGap(18, 18, 18).addComponent(jLabel6)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 0,
														Short.MAX_VALUE)
												.addGap(18, 18, 18).addComponent(jLabel3)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 164,
														javax.swing.GroupLayout.PREFERRED_SIZE)
												.addGap(18, 18, 18).addComponent(jLabel2)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 143,
														javax.swing.GroupLayout.PREFERRED_SIZE))
										.addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 636,
												Short.MAX_VALUE)
										.addComponent(jScrollPane5))
								.addGap(58, 58, 58)));

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								layout.createSequentialGroup()
										.addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE,
												javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
										.addContainerGap()));
		layout.setVerticalGroup(
				layout
					.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
					.addComponent(
							jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 
							javax.swing.GroupLayout.DEFAULT_SIZE,
							javax.swing.GroupLayout.PREFERRED_SIZE)
					);

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private String formatTime(Date time) {
		return (time == null ? "" : new SimpleDateFormat("HH:mm:ss.ms").format(time));
	}

	public void insertIntoTransactionTable(int transactionId, String operations, Date timestamp) {
		DefaultTableModel model = (DefaultTableModel) transactionsTable.getModel();
		model.addRow(new Object[] { transactionId, operations, formatTime(timestamp) });
	}

	public void updateBlockTable() {
		// TODO:
		// removeAllLines(blockTable);
		//
		// for (Bloqueio bloqueio : bloqueios) {
		// insertIntoBlockTable(bloqueio.getObjeto(), bloqueio.getTipo(),
		// bloqueio.getTransacao().getNome(),
		// bloqueio.getOperacao().getIndice(), bloqueio.getCriacao(),
		// bloqueio.getRemocao());
		// }
	}

	public void insertIntoBlockTable(String objectName, String blockType, int transactionId) {
		DefaultTableModel model = (DefaultTableModel) blockTable.getModel();
		model.addRow(new Object[] { objectName, blockType, transactionId, formatTime(new Date()) });
	}

	public void updateWaitTable() {
		// TODO:
		// removeAllLines(waitTable);
		//
		// for (Espera espera : esperas) {
		// inserirNaTabelaEspera(espera.getOperacao().getTransacao().getNome(),
		// espera.getOperacao().getTexto(),
		// espera.getOperacao().getIndice(),
		// espera.getTransacaoBloqueadora().getNome(),
		// espera.getCriacao(),
		// espera.getRemocao());
		// }
	}

	public void insertIntoQueue(String type, int requestingTransactionId, String operacao, String blockingTransactionIds) {
		DefaultTableModel model = (DefaultTableModel) queueTable.getModel();
		model.addRow(new Object[] { type, requestingTransactionId, operacao, blockingTransactionIds });
	}

	public void insertIntoRandomizerTable(int transactionId) {
		DefaultTableModel model = (DefaultTableModel) randomizerTable.getModel();
		model.addRow(new Object[] { transactionId, formatTime(new Date()) });
	}

	public void insertIntoSchedulerTable(int transactionId, String operation) {
		DefaultTableModel model = (DefaultTableModel) schedulerTable.getModel();
		
		model.addRow(new Object[] { transactionId, operation, formatTime(new Date()) });
	}

	public void insertIntoGraphTable(String id, String operations) {
		DefaultTableModel model = (DefaultTableModel) graphTable.getModel();
		model.addRow(new Object[] { id, operations });
	}

	public void removeTableLines(Tables table) {
		javax.swing.JTable jTable = null;
		switch (table) {
		case TRANSACTIONS:
			jTable = transactionsTable;
			break;
		case BLOCKS:
			jTable = blockTable;
			break;
		case QUEUE:
			jTable = queueTable;
			break;
		case DEADLOCK_GRAPH:
			jTable = graphTable;
			break;
		case RANDOMIZER:
			jTable = randomizerTable;
			break;
		case SCHEDULER:
			jTable = schedulerTable;
			break;
		}
		removeAllLines(jTable);
	}

	public void removeAllLines(javax.swing.JTable tabela) {
		DefaultTableModel model = (DefaultTableModel) tabela.getModel();
		int rowCount = model.getRowCount();
		for (int i = rowCount - 1; i >= 0; i--) {
			model.removeRow(i);
		}
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JLabel jLabel1;
	private javax.swing.JLabel jLabel2;
	private javax.swing.JLabel jLabel3;
	private javax.swing.JLabel jLabel4;
	private javax.swing.JLabel jLabel5;
	private javax.swing.JLabel jLabel6;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JScrollPane jScrollPane2;
	private javax.swing.JScrollPane jScrollPane3;
	private javax.swing.JScrollPane jScrollPane4;
	private javax.swing.JScrollPane jScrollPane5;
	private javax.swing.JScrollPane jScrollPane6;
	private javax.swing.JTable blockTable;
	private javax.swing.JTable schedulerTable;
	private javax.swing.JTable queueTable;
	private javax.swing.JTable graphTable;
	private javax.swing.JTable randomizerTable;
	private javax.swing.JTable transactionsTable;
	// End of variables declaration//GEN-END:variables
}
